<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Advanced Shader on Cube</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.154.0/build/three.module.js';
        import { OrbitControls } from 'https://unpkg.com/three@0.154.0/examples/jsm/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);

        const vertexShader = `
            varying vec3 vPosition;
            void main() {
                vPosition = position;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            uniform float iTime;
            uniform vec2 iResolution;
            varying vec3 vPosition;

            float hash(float n) {
                return fract(sin(n) * 43758.5453123);
            }

            vec4 noised(vec3 x) {
                // Aquí implementamos la función noised de tu shader original
                vec3 p = floor(x);
                vec3 w = fract(x);
                vec3 u = w * w * (3.0 - 2.0 * w);
                vec3 du = 6.0 * w * (1.0 - w);

                float n = p.x + p.y * 157.0 + 113.0 * p.z;

                float a = hash(n + 0.0);
                float b = hash(n + 1.0);
                float c = hash(n + 157.0);
                float d = hash(n + 158.0);
                float e = hash(n + 113.0);
                float f = hash(n + 114.0);
                float g = hash(n + 270.0);
                float h = hash(n + 271.0);

                float k0 = a;
                float k1 = b - a;
                float k2 = c - a;
                float k3 = e - a;
                float k4 = a - b - c + d;
                float k5 = a - c - e + g;
                float k6 = a - b - e + f;
                float k7 = -a + b + c - d + e - f - g + h;

                return vec4(
                    k0 + k1 * u.x + k2 * u.y + k3 * u.z + k4 * u.x * u.y + k5 * u.y * u.z + k6 * u.z * u.x + k7 * u.x * u.y * u.z,
                    du * (vec3(k1, k2, k3) + u.yzx * vec3(k4, k5, k6) + u.zxy * vec3(k6, k4, k5) + k7 * u.yzx * u.zxy)
                );
            }

            vec4 fbmd(vec3 x) {
                const float scale = 1.5;
                float a = 0.0;
                float b = 0.5;
                float f = 1.0;
                vec3 d = vec3(0.0);
                for(int i = 0; i < 8; i++) {
                    vec4 n = noised(f * x * scale);
                    a += b * n.x;
                    d += b * n.yzw * f * scale;
                    b *= 0.5;
                    f *= 1.8;
                }
                return vec4(a, d);
            }

            vec4 sdBox(vec3 p, vec3 b) {
                vec3 d = abs(p) - b;
                float x = min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
                vec3 n = step(d.yzx, d.xyz) * step(d.zxy, d.xyz) * sign(p);
                return vec4(x, n);
            }

            vec4 map(vec3 p) {
                vec4 d1 = fbmd(p);
                d1.x -= 0.37;
                d1.x *= 0.7;
                d1.yzw = normalize(d1.yzw);
                vec4 d2 = sdBox(p, vec3(1.5));
                return (d1.x > d2.x) ? d1 : d2;
            }

            void mainImage(out vec4 fragColor, in vec2 fragCoord) {
                vec2 p = (2.0 * fragCoord - iResolution) / iResolution.y;
                vec3 ro = vec3(3.0, 3.0, 3.0);
                vec3 rd = normalize(vec3(p, -1.5));
                vec4 res = map(vPosition);
                fragColor = vec4(res.rgb, 1.0);
            }

            void main() {
                mainImage(gl_FragColor, gl_FragCoord.xy);
            }
        `;

        const shaderMaterial = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
                iTime: { value: 0.0 },
                iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
            }
        });

        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const cube = new THREE.Mesh(geometry, shaderMaterial);
        scene.add(cube);

        camera.position.z = 5;

        function animate(time) {
            shaderMaterial.uniforms.iTime.value = time * 0.001;
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            shaderMaterial.uniforms.iResolution.value.set(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
